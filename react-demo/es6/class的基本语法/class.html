<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    // 1. es6的class可以看做只是一个语法糖
    // 2. constructor方法：
    //    constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。
    //    一个类必须有constructor方法，如果没有显示定义，一个空的constructor方法会被默认添加

    // 一下俩种写法等价
    // class Point {

    // }
    // // 空的constructor会被默认添加
    // class Point {
    //   constructor() {

    //   }
    // }

    // constructor默认返回实例对象（即this）  

    // 总结： 1. constructor方法是类的默认方法，空的constructor方法会被自动添加
    //       2. constructor默认返回实例对象(this)，返回的实例可以进行修改 

    // class的静态方法：
    //   类相当于实例的原型，所有在类中定义的方法，都会被实例继承
    //   静态方法：在方法前加上static 关键字，表示该方法不会被实例继承，而是直接通过类来调用
    // class Foo {
    //   static classMethod() {
    //     return 'hello';
    //   }
    // }
    // // 在Foo类上调用
    // Foo.classMethod(); // 'hello'
    // var foo = new Foo();
    // // 不是在Foo类的实例上调用
    // foo.classMethod(); // Uncaucht TypeError: foo.classMethod is not a function

    // 如果静态方法中包含this关键字，这个this指的是类，而不是实例
    // class Foo {
    //   static bar() {
    //     this.baz()
    //   }
    //   // 静态方法可以和非静态方法重名
    //   static baz() {
    //     console.log('hello');
    //   }
    //   baz() {
    //     console.log('world');
    //   }
    // }
    // Foo.bar(); // 'hello'
    // 父类的静态方法可以被子类继承
    // class Foo {
    //   static classMethod() {
    //     return 'hello';
    //   }
    // }
    // class Bar extends Foo {

    // }
    // Bar.classMethod();
    // console.log(Bar.classMethod()); // hello

    // 静态方法也可以从super对象上调用
    class Foo {
      static classMethod() {
        return 'hello';
      }
    }
    class Bar extends Foo {
      static classMethod() {
        return super.classMethod() + ', too';
      }
    }
    Bar.classMethod(); // 'hello, too'
  </script>
</body>

</html>
